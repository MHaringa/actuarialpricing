---
title: "Model refinement"
author: "Martin Haringa"
date: "22 maart 2021"
output: rmdformats::downcute
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Inleiding

Wanneer het premiemodel eenmaal een aantal iteraties heeft doorstaan en het premiemodel alleen significante parameters bevat, kan een smoothing op de geschatte parameters worden toegepast om de overgang tussen premieklassen te verkleinen. Het verkleinen van deze premieovergangen is vaak wenselijk vanuit commercieel oogpunt. Daarnaast is het mogelijk dat er op basis van juridische of commerciele redenen beperkingen om bepaalde factoren worden gezet. Denk hierbij aan een BM-ladder. 

Het vaststellen van nieuwe premies bestaat uit vier stappen. Dit document beschrijft punt 3:

1. Pre-modelleer analyses, beschouwt data preparatie en ook het doen van portefeuille onderzoek
2. Model iteraties, maakt een premiemodel en doet onderzoek naar zowel model selectie als model validatie
3. Model refinement, onderzoekt het toepassen van smoothing en het invoegen van restricties (bijv. BM-ladder)
4. Interpretatie van de resultaten, vergelijkt de uitkomsten van het model met de bestaande premiestelling

Aan de hand van een aantal voorbeelden werkt dit document Stap 3 (model refinement) met behulp van `insurancerating` uit. De eerste sectie beschrijft de portefeuille, vervolgens wordt een premiemodel geschat en daarna model refinement toegepast. 

# Portefeuille
De technieken om het model te verfijnen worden in dit document toegepast op een WA-portefeuille voor motorrijtuigen. Deze voorbeeld portefeuille bevat kenmerken van 30.000 polishouders. Het gaat om de leeftijd van de polishouder, het aantal claims, exposure, schadebedrag in Euro's, het vermogen van de motor (in kW), BM-trede (0-22) en een regio indicator (0-3). De voorbeeld portefeuille is afgeleid van een grote Belgische verzekeraar. 


```{r, warning = FALSE, message = FALSE}

library(insurancerating)
library(dplyr)
glimpse(MTPL)

```

## Clustering van continue variabelen

Voor de continue variabelen in de portefeuille wordt een clustering aangebracht. Het doel is om de clusters zo te maken dat klanten met een vergelijkbaar risico in dezelfde groep vallen. Deze clusters kunnen dan vervolgens eenvoudig worden opgenomen als risico factor in de GLM. `insurancerating` gebruikt eerst een GAM om het risico in de schatten en vervolgens een *evolutionary tree* om clusters te maken. Zie `?fit_gam` voor een uitgebreide beschrijving van de technieken. 

De voorbeeld portefeuille bevat twee continue variabelen: de leeftijd van de polishouder en het vermogen van de motor (in kW). Voor deze beide continue variabelen wordt een clustering aangebracht. 

```{r gam_leeftijd_freq}

# Claim frequency leeftijd polishouder
age_policyholder_frequency <- fit_gam(data = MTPL, 
                                      nclaims = nclaims, 
                                      x = age_policyholder, 
                                      exposure = exposure)

# Maak clusters 
clusters_age_freq <- construct_tariff_classes(age_policyholder_frequency)

# Toon plot van de GAM inclusief clustering
autoplot(clusters_age_freq)
```

Doe bovenstaande ook voor het vermogen (in kW) van het voertuig:

```{r}

# Claim frequency vermogen voertuig
power_frequency <- fit_gam(data = MTPL, 
                           nclaims = nclaims, 
                           x = power, 
                           exposure = exposure)

# Maak clusters
clusters_power_freq <- construct_tariff_classes(power_frequency)

```

Voeg beide clusteringen als nieuwe kolommen toe aan `MTPL`:

```{r}

MTPL_cat <- MTPL %>%
  mutate(age_policyholder_freq_cat = clusters_age_freq$tariff_classes) %>%
  mutate(power_freq_cat = clusters_power_freq$tariff_classes) 

```

Voeg ook een kolom toe met BM-trede (1-3): 

```{r}

MTPL_bm <- MTPL_cat %>%
  mutate(bm = c(rep("1",5000), rep("2",4000), rep("3", 21000)))

```


Vervolgens worden de kolommen met `characters` aangepast naar `factors`. Dit wordt gedaan omdat het mogelijk is om in `factors` een zelfgekozen ordering aan te brengen. Vaak wordt er in een GLM bij schadeverzekeringsproducten voor gekozen om het niveau met de grootste *exposure* op te nemen als referentieklasse. Dit betekent dat de coëfficiënt van dit niveau in de risico factor gelijk wordt gesteld aan 1. 

```{r}

MTPL_bewerkt <- MTPL_bm %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), ~biggest_reference(., exposure)))

```

`MTPL_bewerkt` wordt gebruikt als data set om het risicomodel te schatten. `MTPL_bewerkt` bevat de volgende kolommen:

```{r}

glimpse(MTPL_bewerkt)

```

# Risicomodel 

Op basis van `MTPL_bewerkt` wordt zowel een frequentiemodel als een schadelast model geschat. Vervolgens wordt voor iedere rij in `MTPL_bewerkt` de risicopremie bepaald door het te verwachten aantal schades (op basis van het frequentiemodel) en de te verwachten schadelast (op basis van het schadelastmodel) met elkaar te vermenigvuldigen. Daarna wordt deze risicopremie nogmaals geschat maar dan met restricties op bijvoorbeeld de BM-ladder of het *smoothen* van de overgang van de risicopremie tussen de verschillende clusters. 

## Frequentiemodel

Als eerste wordt een Poisson GLM geschat voor de frequentie. 

```{r}

mod_freq <- glm(nclaims ~ zip + power_freq_cat + age_policyholder_freq_cat, 
                offset = log(exposure), 
                family = "poisson", 
                data = MTPL_bewerkt)

```

## Schadelastmodel

Voor het schadelastmodel wordt een Gamma GLM geschat. Dit model wordt geschat op basis van de rijen met een positieve schadelast.  

```{r}

mod_sev <- glm(amount ~ bm + zip, 
               weights = nclaims, 
               family = Gamma(link = "log"), 
               data = MTPL_bewerkt %>% filter(amount > 0))

```

## Risicomodel

Op basis van `mod_freq` en `mod_sev` wordt per rij in `MTPL_bewerkt` het te verwachten aantal schades en de te verwachten schadelast bepaald. De risicopremie wordt vervolgens bepaald door het product van het te verwachten aantal schades en de te verwachten schadelast te nemen. 

```{r}

MTPL_premie <- MTPL_bewerkt %>%
  add_prediction(mod_freq, mod_sev) %>%
  mutate(premium = pred_nclaims_mod_freq * pred_amount_mod_sev)

```

Toon uitkomsten:

```{r}

glimpse(MTPL_premie)

```


# Risicomodel verfijning

Nu een risicomodel is geschat, kan smoothing op de geschatte parameters worden toegepast om de overgang tussen premieklassen te verkleinen. Daarnaast is het mogelijk dat er op basis van juridische of commerciele redenen beperkingen om bepaalde factoren worden gezet. Deze sectie geeft toepassingen van beide methoden.   

## Burning model

Om het model te kunnen verfijnen wordt eerst een zogenaamd burning model geschat. Hierin wordt de risicopremie uit de vorige stap nogmaals gemodelleerd. Hierin is de premie de afhankelijke variabele. Dit *burning model* wordt in eerste instantie geschat zonder restricties. Dit model wordt geschat omdat het smoothen toegepast dient te worden op de risicopremie en niet op de gemodelleerde frequentie of schadelast. 

De gehanteerde niveaus voor de onafhankelijke variabelen in het *burning model* zijn in dit geval gelijk aan de niveaus die gewenst zijn in de uiteindelijke premiestelling. Het is hier niet noodzakelijk dat de niveaus gelijk zijn aan de niveaus in het frequentiemodel of het schadelastmodel. 

```{r}

# Burning model zonder restricties
burn_unrestricted <- glm(premium ~ zip + bm + 
                           power_freq_cat + age_policyholder_freq_cat, 
                         weights = exposure, 
                         family = Gamma(link = "log"), 
                         data = MTPL_premie) 

```


## Smoothen

Dit eerste deel bevat een *smoothing* op de risicofactor voor de leeftijd van de polishouder. De leeftijd van de polishouder bestaat in totaal uit vijf clusters. Het doel van het *smoothen* is om de overgang in premie tussen de clusters te verkleinen. `smooth_coef()` past een *smoothing* toe. Vervolgens geeft `autoplot()` een figuur met daarin de oude clusters en de nieuwe clusters. 

`smooth_coef()` kent een vijftal argumenten. Het eerste argument `model` is het GLM object om de smoothing op toe te passen. `x_cut` is de naam van de variabele met daarin de geclusterde leeftijden. Vervolgens is `x_org` de originele variabele met de niet geclusterde leeftijden. Beide variabelen moeten voorkomen in de data die is gebruikt in het glm object. In dit geval zitten beide variabelen in `MTPL_premie`. Als laatste is `breaks` een vector met daarin de grenzen van de nieuwe clusters. In dit geval lopen de grenzen van 18 tot en met 95 jaar, met een stapgrootte van 5 jaar. Desgewenst is het uiteraard mogelijk om de vector zodanig aan te passen dat er grotere en kleinere clusters worden gemaakt. 

```{r}

burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  autoplot()

```

Het is ook mogelijk om de graad van de polynoom aan te passen. Op basis van *expert judgement* kan hiermee een gewenste *smoothing* worden gedaan. Onderstaand voorbeeld geeft een eerstegraads polynoom. 

```{r}

burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              degree = 1,
              breaks = seq(18, 95, 5)) %>%
  autoplot()

```

Om het model opnieuw te schatten is het nodig om in plaats van `autoplot()` gebruik te maken van `refit_glm()`. Dit betekent:

```{r, eval = FALSE}

burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  refit_glm()

```

`refit_glm()` schat een GLM met daarin een toegepaste *smoothing* op de leeftijd van de polishouder. Deze *smoothing* wordt als offset toegevoegd aan de GLM. Een offset is een *fixed vector* die wordt opgeteld bij de *linear predictor* van het model. In het geval het model al een offset bevatte wordt de nieuwe offset eerst samengenomen met de al bestaande offset (d.w.z. als de bestaande offset is gelijk aan $offset = \log(a)$ dan het toevoegen van de nieuwe offset voor de *smoothing* $b$ geeft als nieuwe offset $\text{offset} = \log(a) + \log(b) = \log(a \cdot b)$). 

Het is ook mogelijk om meer dan 1 risico factor te smoothen:

```{r}

burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  autoplot()

```

Schat het model opnieuw:

```{r}

burn_restricted <- burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  refit_glm()

```

Bovenstaande output geeft de geschatte coefficienten voor de zip factoren. De overige factoren zijn in de offset opgenomen. 

```{r}

rating_factors(burn_restricted)

```


## Restricties

Het is ook mogelijk om een risico factor vast te zetten. De coefficienten in deze regiofactor zijn bepaald op basis van commerciele overwegingen. In de praktijk zal de BM-ladder vaak worden vastgezet en niet een regiofactor. Om deze toe te voegen in het model wordt eerst een zogenaamd burning model geschat. Hierin wordt de bepaalde risicopremie uit de vorige stap nogmaals gemodelleerd. Hierin is de premie de afhankelijke variabele. 

Om restricties toe te kunnen passen wordt eerst een data.frame gedefinieerd met de restricties per niveau in de risico factor. Het data.frame dient in de eerste kolom de niveaus van de risicofactor te bevatten. In dit geval zijn dit de waarden 0,1,2 en 3 voor de niveaus in de regiofactor. In de tweede kolom dienen de nieuwe coefficienten te worden benoemd. De kolomnaam van de tweede kolom is hier vrij te kiezen. De naam van deze kolom zal ook gebruikt worden als factor in het risicomodel met de vastgezette coefficienten voor regio. Het is daarom belangrijk om een kolomnaam te gebruiken die duidelijk aangeeft dat het nog steeds om de regiofactor zip gaat maar nu met restricties. In het voorbeeld wordt deze kolom `zip_rst` genoemd. 

```{r, eval = TRUE}

zip_df <- data.frame(zip = c(0,1,2,3),
                     zip_restricted = c(0.8, 0.9, 1, 1.2))

zip_df

```

Dit data.frame met restricties wordt nu met behulp van `restrict_coef()` toegepast op het burning model:

```{r, eval = TRUE}

burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  print()

```

Toon de nieuwe formule. Hierin is de risico factor met restricties opgenomen in de offset-term. Een offset is een fixed vector die wordt opgeteld bij de linear predictor van een model. 

Het is ook mogelijk om de vastgezette coefficienten voor de regiofactor af te zetten tegen de geschatte risicofactoren uit het model:

```{r, eval = TRUE}

burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  autoplot()

```

Nu de coefficienten zijn vastgezet kan het model opnieuw worden geschat:

```{r, eval = FALSE}

burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  refit_glm()

```

De reden dat het model niet in een keer opnieuw wordt geschat (maar pas aan het eind `refit_glm()`) is dat het mogelijk is om restricties op meerdere risico factoren toe te passen. Bijvoorbeeld:

```{r}

bm_df <- data.frame(bm = c(1,2,3), bm_restricted = c(1.4, 1.2, 1))

burn_restricted2 <- burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  restrict_coef(., bm_df) %>% 
  refit_glm()

```

Uiteraard is het ook mogelijk om beide varianten te combineren:

```{r}

burn_restricted <- burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  refit_glm() 
  
rating_factors(burn_restricted)

```




```{r, echo = FALSE, eval = FALSE}

# 1. Smooth, 2. Restrict
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  restrict_coef(., zip_df) %>%
  refit_glm() %>%
  rating_factors()

# 1. Restrict, 2. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  refit_glm() %>%
  rating_factors()

# 1. Restrict, 2. Restrict, 3. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  refit_glm() %>%
  rating_factors()

# 1. Smooth, 2. Smooth, 3. Restrict
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  restrict_coef(., zip_df) %>%
  refit_glm() %>%
  rating_factors()

# 1. Restrict, 2. Smooth, 3. Restrict
burn_unrestricted %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  restrict_coef(., zip_df) %>%
  refit_glm() %>%
  rating_factors()

# 1. Smooth, 2. Restrict, 3. Smooth
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  restrict_coef(., zip_df) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  refit_glm() %>%
  rating_factors()

# 1. Smooth, 2. Restrict, 3. Smooth, 4. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  refit_glm() %>%
  rating_factors()


```




```{r, echo = FALSE, eval = FALSE}
# 1. Smooth, 2. Restrict
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  restrict_coef(., zip_df) %>%
  autoplot()

burn_unrestricted %>%
  restrict_coef(., bm_df) %>%
  restrict_coef(., zip_df) %>%
  autoplot(.)

# 1. Restrict, 2. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  autoplot()

# 1. Restrict, 2. Restrict, 3. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  autoplot()


# 1. Smooth, 2. Smooth, 3. Restrict
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  restrict_coef(., zip_df) %>%
  autoplot()


# 1. Restrict, 2. Smooth, 3. Restrict
burn_unrestricted %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  restrict_coef(., zip_df) %>%
  autoplot()


# 1. Smooth, 2. Restrict, 3. Smooth
burn_unrestricted %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  restrict_coef(., zip_df) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  autoplot()


# 1. Smooth, 2. Restrict, 3. Smooth, 4. Smooth
burn_unrestricted %>%
  restrict_coef(., zip_df) %>%
  restrict_coef(., bm_df) %>%
  smooth_coef(x_cut = "age_policyholder_freq_cat", 
              x_org = "age_policyholder", 
              breaks = seq(18, 95, 5)) %>%
  smooth_coef(x_cut = "power_freq_cat", 
              x_org = "power", 
              degree = 3,
              breaks = seq(30, 250, 20)) %>%
  autoplot()


```

